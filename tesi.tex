\documentclass[12pt,a4paper]{report}
\usepackage[italian]{babel}
\usepackage{newlfont}
\usepackage{color}
\textwidth=450pt\oddsidemargin=0pt
\usepackage{hyperref}
\usepackage{float}
\floatplacement{figure}{H}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{biblatex}
\addbibresource{bibliography.bib}


\begin{document}
\begin{titlepage}
%
%
% UNA VOLTA FATTE LE DOVUTE MODIFICHE SOSTITUIRE "RED" CON "BLACK" NEI COMANDI \textcolor
%
%
\begin{center}
{{\Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di Bologna}}}} 
\rule[0.1cm]{15.8cm}{0.1mm}
\rule[0.5cm]{15.8cm}{0.6mm}
\\\vspace{3mm}

{\small{\bf Scuola di Scienze \\ 
Dipartimento di Fisica e Astronomia\\
Corso di Laurea in Fisica}}

\end{center}

\vspace{23mm}

\begin{center}\textcolor{red}{
%
% INSERIRE IL TITOLO DELLA TESI
%
{\LARGE{\bf TITOLO TESI}}\\
}\end{center}

\vspace{50mm} \par \noindent

\begin{minipage}[t]{0.47\textwidth}
%
% INSERIRE IL NOME DEL RELATORE CON IL RELATIVO TITOLO DI DOTTORE O PROFESSORE
%
{\large{\bf Relatore: \vspace{2mm}\\\textcolor{black}{
Prof. Armando Bazzani}\\\\
%
% INSERIRE IL NOME DEL CORRELATORE CON IL RELATIVO TITOLO DI DOTTORE O PROFESSORE
%
% SE NON AVETE UN CORRELATORE CANCELLATE LE PROSSIME 3 RIGHE
%
\textcolor{red}{
\bf Correlatore: (eventuale)
\vspace{2mm}\\
Prof./Dott. Nome Cognome\\\\}}}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.47\textwidth}\raggedleft \textcolor{black}{
{\large{\bf Presentata da:
\vspace{2mm}\\
Gregorio Berselli}}}
\end{minipage}

\vspace{40mm}

\begin{center}
Anno Accademico \textcolor{black}{2021/2022}
\end{center}

\end{titlepage}

\chapter*{\centering \Large Abstract}

\tableofcontents
\listoffigures

\chapter*{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[ybar interval,
            area style,
            width = \textwidth,
            height = 0.75\textwidth,
            xlabel = {Densità di veicoli},
            ylabel = {Numero di strade},]
        \addplot+[
            ybar interval,
            mark=no,
            line width = 1.25pt
        ] file {./data/499.dat};
        \end{axis}
    \end{tikzpicture}
    \caption{\emph{Prova.}}
\end{figure}
% \begin{figure}[H]
%     \centering
%     \begin{tikzpicture}
%         \begin{axis}[ybar interval,
%             area style,
%             ymin=0,
%             xmin=0.24,
%             xmax=0.95,
%             width = \textwidth,
%             height = 0.75\textwidth,
%             xlabel = {Velocità},
%             ylabel = {Densità di veicoli},]
%         \addplot+[
%             ybar interval,
%             mark=no,
%             line width = 1.25pt
%         ] file {./data/175.dat};
%         \end{axis}
%     \end{tikzpicture}
%     \caption{\emph{Prova.}}
% \end{figure}
% \begin{figure}[H]
%     \centering
%     \begin{tikzpicture}
%         \begin{axis}[ybar interval,
%             area style,
%             ymin=0,
%             xmin=0.24,
%             width = \textwidth,
%             height = 0.75\textwidth,
%             xlabel = {Velocità},
%             ylabel = {Densità di veicoli},]
%         \addplot+[
%             ybar interval,
%             mark=no,
%             line width = 1.25pt
%         ] file {./data/150.dat};
%         \end{axis}
%     \end{tikzpicture}
%     \caption{\emph{Prova.}}
% \end{figure}

\section*{Random Walk su network}

\section*{Modelli di traffico}

\chapter{Costruzione del modello}

\chapter{Implementazione}
Il modello descritto in precedentza è stato implementato tramite un software scritto in C++.
\section{Classi}
Sfruttando la programmazione a oggetti su cui è basato il linguaggio C++ si è diviso il modello in varie classi.
\subsection{VehicleType}
La classe a livello inferiore è \emph{VehicleType} che, come suggerisce il nome, definisce una tipologia di veicolo.
In questo modello ogni veicolo è caratterizzato dai parametri di input nodo sorgente e nodo destinazione.
Tuttavia, per muoversi sul network, ogni tipologia di veicolo necessita anche di una matrice di transizione contenente le probabilità di effettuare o meno un passo in una specifica dimensione.
Questa matrice viene solo dichiarata come parametro della classe e viene impostata dopo la definizione del network.
\subsection{Vehicle}
Dopo aver definito le tipologie di veicoli è necessario definire anche i veicoli stessi.
La classe \emph{Vehicle} rappresenta dunque gli agenti che andranno a muoversi sul network stradale.
Un vettore statico di \emph{VehicleType} permette ad ogni veicolo di avere una tipologia definita, tramite un parametro indiciale che determina la posizione nel vettore.
Ogni agente ha inoltre due coordinate che ne definiscono la posizione: nodo attuale e strada attuale.
Per permetterne il movimento nel tempo sono presenti altri due parametri, non necessari in input, rappresentanti la velocità del veicolo, dettata dalla strada sulla quale si trova, e la penalità di tempo che questo deve scontare, dipendente sia dalla velocità del veicolo stesso sia alla densità di veicoli presente sulla strada in cui si trova.
\subsection{Street}
Una volta definiti i veicoli è necessario definire le proprietà dei collegamenti tra i vari nodi (incroci) della rete.
Ogni istanza della classe \emph{Street} rappresenta dunque un collegamento tra due nodi.
I parametri da fornire come input per distinguere una strada in maniera univoca sono dunque l'indice del nodo sorgente e l'indice del nodo destinazione.
Si presti ora attenzione al fatto che ogni strada abbia una direzione: considerando due nodi generici $i$ e $j$, la strada che connette $i\to j$ sarà differente dalla strada che connette $j \to i$.
Questa distinzione permette sia una gestione delle densità di veicoli più efficiente e coerente con la realtà, non avendo interferenza tra le corsie, sia l'inserimento di strade a senso unico nella rete.\\
Nella classe \emph{Street} viene poi definita un parametro di controllo del modello, ossia la lunghezza media dei veicoli.
Altri parametri della strada sono la sua lunghezza, il numero $n$ di veicoli su di essa, la velocità massima consentita ,il numero di corsie (direzionate come la strada stessa) e la capacità massima $n_{max}$ di veicoli presenti contemporaneamente.
Si noti come mentre un veicolo conosce esattamente la strada in cui si trova ciò non sia vero per la strada in quanto quest'ultima possiede informazione solamente sul numero totale di veicoli presenti.
La velocità effettiva mantenibile su una strada, essendo un valore altamente dinamico, non viene considerato come parametro (quindi immagazzinato in memoria) ma viene calcolato tramite una funzione quando necessario.
In particolare, l'andamento della velocità su una strada segue la funzione
\begin{equation}
    v(n)=v_{max}\left(1-0.75\frac{n}{n_{max}}\right)
    \label{equation:velocity}
\end{equation}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            grid = both,
            major grid style = {lightgray},
            minor grid style = {lightgray},
            ymin=0,
            xmin=0,
            xmax=1,
            width = 0.7\textwidth,
            height = 0.5\textwidth,
            xlabel = {Densità ($\frac{n}{n_{max}}$)},
            ylabel = {Velocità},]
            \addplot[
                domain = 0:1,
                smooth,
                color = blue,
                line width = 1.5pt,] {1-0.75*x};
        \end{axis}
    \end{tikzpicture}
    \caption[Velocità nel modello]{\emph{Ipotesi dell'andamento della velocità in funzione della densità.}}
    \label{figure:velocity}
\end{figure}
Come visibile in Fig. \ref{figure:velocity} anche una volta raggiunta la densità massima i veicoli non si fermano ma si immettono sulla strada, quando si libera sufficiente spazio, con una velocità minima pari al $25\%$ della velocità massima.
\subsection{Graph}
Ultima classe definita, che comprende tutte le precedenti, è la classe \emph{Graph}, la quale costruisce effettivamente il network stradale.
Parametro di input necessario per creare un'istanza è infatti la matrice di adiacenza, che definisce le connessioni tra i nodi.
Tramite essa viene poi generato un vettore di puntatori a \emph{Street} che genera le connessioni tra i nodi come strade.\\
Il movimento degli agenti sul network è determinato dalla matrice di transizione assegnata alle varie tipologie di veicoli.
Questa viene generata tramite l'utilizzo del famoso algoritmo Dijkstra \cite{dijkstra} e si basa quindi sulla ricerca del \emph{best path} (a lunghezza inferiore) dalla posizione dell'agente alla destinazione definita dal suo \emph{VehicleType}.
Si è poi deciso di introdurre un parametro di temperatura al network per poter permettere ai veicoli di seguire un percorso differente rispetto al best path fornito dall'algoritmo Dijkstra.
L'algoritmo di evoluzione, infatti, assegna peso 1 ai best path e un peso $\pi$ variabile tra 0 e 1 ai percorsi più lunghi.
Quest'ultimo peso varia in base alla temperatura del sistema secondo la funzione
\begin{equation}
    \pi(T)=\tanh(kT)
\end{equation}
dove $k$ è un parametro di controllo del modello.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            grid = both,
            major grid style = {lightgray},
            minor grid style = {lightgray},
            width = 0.7\textwidth,
            height = 0.5\textwidth,
            xlabel = {kT},
            ylabel = {$\pi(kT)$},]
            \addplot[
                domain = 0:3.1415,
                smooth,
                color = blue,
                line width = 1.5pt,] {tanh(x)};
        \end{axis}
    \end{tikzpicture}
    \caption[Temperatura nel modello]{\emph{Probabilità di errore in funzione della temperatura.}}
    \label{figure:temperature}
\end{figure}
Si procede poi alla normalizzazione a 1 di ogni vettore riga della matrice in modo tale da poter ottenere la probabilità di transizione.
Una volta ottenute le probabilità di transizione il sistema può quindi evolvere tenendo presente che:
\begin{itemize}
    \item se un agente prova a muovere su una strada piena questo movimento viene impedito e di fatto si perde uno step temporale;
    \item la velocità di ogni veicolo viene impostata all'ingresso in una strada e non più modificata fino all'ingresso nella strada successiva. 
\end{itemize}

\section{Esecuzione}

\section{Performance}
Il programma è stato compilato utilizzando il compilatore gcc-9 su Ubuntu 20.04 nel Windows Subsystem for Linux.
La compilazione è stata effettuata utilizzando le flag
\begin{verbatim}
    -O3 -Wall -Wextra -fsanitize=address
\end{verbatim}
in cui:
\begin{itemize}
    \item \emph{O3} indica il livello di ottimizzazione massima volto a ridurre il tempo di esecuzione del programma;
    \item \emph{Wall} e \emph{Wextra} consentono di correggere ogni tipo di warning che sorge in compilazione;
    \item \emph{fsanitize=address} consente di ottenere un'ottima gestione della memoria.
\end{itemize}


\chapter{Risultati}

\printbibliography
\end{document}
